#version 450
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(constant_id = 0) const uint kVoxelResolution = 1;

layout(std430, set = 0, binding = 0) buffer uuOctree { uint uOctree[]; };

#define CAMERA_SET 1
#include "camera.glsl"

layout(std430, set = 2, binding = 0) readonly buffer uuRayData {
    vec2 uScreenCoords;
};

#define STACK_SIZE 23
#define EPS 3.552713678800501e-15
uint stack[STACK_SIZE];

bool Octree_RayMarchLeaf(vec3 o, vec3 d, out vec3 o_pos, out vec3 o_color, out vec3 o_normal) {
	d.x = abs(d.x) >= EPS ? d.x : (d.x >= 0 ? EPS : -EPS);
	d.y = abs(d.y) >= EPS ? d.y : (d.y >= 0 ? EPS : -EPS);
	d.z = abs(d.z) >= EPS ? d.z : (d.z >= 0 ? EPS : -EPS);

	vec3 t_coef = 1.0f / -abs(d);
	vec3 t_bias = t_coef * o;

	uint oct_mask = 0u;
	if (d.x > 0.0f)
		oct_mask ^= 1u, t_bias.x = 3.0f * t_coef.x - t_bias.x;
	if (d.y > 0.0f)
		oct_mask ^= 2u, t_bias.y = 3.0f * t_coef.y - t_bias.y;
	if (d.z > 0.0f)
		oct_mask ^= 4u, t_bias.z = 3.0f * t_coef.z - t_bias.z;

	float t_min = max(max(2.0f * t_coef.x - t_bias.x, 2.0f * t_coef.y - t_bias.y), 2.0f * t_coef.z - t_bias.z);
	float t_max = min(min(t_coef.x - t_bias.x, t_coef.y - t_bias.y), t_coef.z - t_bias.z);
	t_min = max(t_min, 0.0f);
	float h = t_max;

	uint parent = 0u;
	uint cur = 0u;
	vec3 pos = vec3(1.0f);
	uint idx = 0u;
	if (1.5f * t_coef.x - t_bias.x > t_min)
		idx ^= 1u, pos.x = 1.5f;
	if (1.5f * t_coef.y - t_bias.y > t_min)
		idx ^= 2u, pos.y = 1.5f;
	if (1.5f * t_coef.z - t_bias.z > t_min)
		idx ^= 4u, pos.z = 1.5f;

	uint scale = STACK_SIZE - 1;
	float scale_exp2 = 0.5f;

	while (scale < STACK_SIZE) {
		if (cur == 0u)
			cur = uOctree[parent + (idx ^ oct_mask)];

		vec3 t_corner = pos * t_coef - t_bias;
		float tc_max = min(min(t_corner.x, t_corner.y), t_corner.z);

		if ((cur & 0x80000000u) != 0 && t_min <= t_max) {
			float half_scale_exp2 = scale_exp2 * 0.5f;
			vec3 t_center = half_scale_exp2 * t_coef + t_corner;

			if ((cur & 0x40000000u) != 0)
				break;

			if (tc_max < h)
				stack[scale] = parent;
			h = tc_max;

			parent = cur & 0x3fffffffu;

			idx = 0u;
			--scale;
			scale_exp2 = half_scale_exp2;
			if (t_center.x > t_min)
				idx ^= 1u, pos.x += scale_exp2;
			if (t_center.y > t_min)
				idx ^= 2u, pos.y += scale_exp2;
			if (t_center.z > t_min)
				idx ^= 4u, pos.z += scale_exp2;

			cur = 0;

			continue;
		}

		uint step_mask = 0u;
		if (t_corner.x <= tc_max)
			step_mask ^= 1u, pos.x -= scale_exp2;
		if (t_corner.y <= tc_max)
			step_mask ^= 2u, pos.y -= scale_exp2;
		if (t_corner.z <= tc_max)
			step_mask ^= 4u, pos.z -= scale_exp2;

		t_min = tc_max;
		idx ^= step_mask;

		if ((idx & step_mask) != 0) {
			uint differing_bits = 0;
			if ((step_mask & 1u) != 0)
				differing_bits |= floatBitsToUint(pos.x) ^ floatBitsToUint(pos.x + scale_exp2);
			if ((step_mask & 2u) != 0)
				differing_bits |= floatBitsToUint(pos.y) ^ floatBitsToUint(pos.y + scale_exp2);
			if ((step_mask & 4u) != 0)
				differing_bits |= floatBitsToUint(pos.z) ^ floatBitsToUint(pos.z + scale_exp2);
			scale = findMSB(differing_bits);
			if (scale >= STACK_SIZE)
				break;
			scale_exp2 = uintBitsToFloat((scale - STACK_SIZE + 127u) << 23u);

			parent = stack[scale];

			uint shx = floatBitsToUint(pos.x) >> scale;
			uint shy = floatBitsToUint(pos.y) >> scale;
			uint shz = floatBitsToUint(pos.z) >> scale;
			pos.x = uintBitsToFloat(shx << scale);
			pos.y = uintBitsToFloat(shy << scale);
			pos.z = uintBitsToFloat(shz << scale);
			idx = (shx & 1u) | ((shy & 1u) << 1u) | ((shz & 1u) << 2u);

			h = 0.0f;
			cur = 0;
		}
	}

	vec3 norm, t_corner = t_coef * (pos + scale_exp2) - t_bias;
	if (t_corner.x > t_corner.y && t_corner.x > t_corner.z)
		norm = vec3(-1, 0, 0);
	else if (t_corner.y > t_corner.z)
		norm = vec3(0, -1, 0);
	else
		norm = vec3(0, 0, -1);

	if ((oct_mask & 1u) == 0u)
		norm.x = -norm.x;
	if ((oct_mask & 2u) == 0u)
		norm.y = -norm.y;
	if ((oct_mask & 4u) == 0u)
		norm.z = -norm.z;

	if ((oct_mask & 1u) != 0u)
		pos.x = 3.0f - scale_exp2 - pos.x;
	if ((oct_mask & 2u) != 0u)
		pos.y = 3.0f - scale_exp2 - pos.y;
	if ((oct_mask & 4u) != 0u)
		pos.z = 3.0f - scale_exp2 - pos.z;

	o_pos = clamp(o + t_min * d, pos, pos + scale_exp2);
	if (norm.x != 0)
		o_pos.x = norm.x > 0 ? pos.x + scale_exp2 + EPS * 2 : pos.x - EPS;
	if (norm.y != 0)
		o_pos.y = norm.y > 0 ? pos.y + scale_exp2 + EPS * 2 : pos.y - EPS;
	if (norm.z != 0)
		o_pos.z = norm.z > 0 ? pos.z + scale_exp2 + EPS * 2 : pos.z - EPS;
	o_normal = norm;
	o_color = vec3(cur & 0xffu, (cur >> 8u) & 0xffu, (cur >> 16u) & 0xffu) * 0.00392156862745098f;

	return scale < STACK_SIZE && t_min <= t_max;
}

void main() {
    vec3 o = uPosition.xyz;
    vec3 d = Camera_GenRay(uScreenCoords);
    
    // Debug: Log ray generation
    // Ray origin: o, Ray direction: d, Screen coords: uScreenCoords
    
    vec3 pos, color, normal;
    bool hit = Octree_RayMarchLeaf(o, d, pos, color, normal);
    
    if (hit) {
        // Debug: Ray hit at position pos with color color
        // Use the same octree traversal approach as the rendering pipeline
        uint level_dim = kVoxelResolution;
        vec3 voxel_pos_f = pos * float(level_dim);
        uvec3 voxel_pos = uvec3(clamp(voxel_pos_f, vec3(0.0), vec3(float(level_dim - 1u))));
        
        // Debug: Voxel position calculation - pos: pos, voxel_pos: voxel_pos, level_dim: level_dim
        
        // Navigate to the leaf node containing the voxel
        uint idx = 0u;
        uint current_level_dim = level_dim;
        
        while (current_level_dim > 1u) {
            current_level_dim >>= 1;
            bvec3 cmp = greaterThanEqual(voxel_pos, uvec3(current_level_dim));
            uint child_idx = uint(cmp.x) | (uint(cmp.y) << 1u) | (uint(cmp.z) << 2u);
            idx = (uOctree[idx] & 0x3fffffffu) + child_idx;
            voxel_pos -= uvec3(cmp) * current_level_dim;
            
            // Check if this node exists
            if ((uOctree[idx] & 0x80000000u) == 0u) {
                return; // Node doesn't exist, nothing to destroy
            }
        }
        
        // At leaf level, destroy the voxel if it exists
        if ((uOctree[idx] & 0x80000000u) != 0u) {
            // Debug: Destroying voxel at octree index idx with value uOctree[idx]
            // Clear the existence bit (0x80000000u) while preserving other data
            atomicAnd(uOctree[idx], 0x7fffffffu);
            // Debug: Voxel destroyed successfully
        } else {
            // Debug: No voxel found at octree index idx (value: uOctree[idx])
        }
    } else {
        // Debug: Ray missed - no intersection found with octree
    }
    }
}
