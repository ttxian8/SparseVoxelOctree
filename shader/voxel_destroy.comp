#version 450
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(constant_id = 0) const uint kVoxelResolution = 1;

layout(std430, set = 0, binding = 0) buffer uuOctree { uint uOctree[]; };
layout(std430, set = 2, binding = 0) readonly buffer uuRayData {
    vec3 uRayOrigin;
    vec3 uRayDirection;
};

#define STACK_SIZE 23
#define EPS 3.552713678800501e-15
uint stack[STACK_SIZE];

bool RayMarchLeaf(vec3 o, vec3 d, out vec3 o_pos, out vec3 o_color, out vec3 o_normal) {
    d.x = abs(d.x) > EPS ? d.x : (d.x >= 0 ? EPS : -EPS);
    d.y = abs(d.y) > EPS ? d.y : (d.y >= 0 ? EPS : -EPS);
    d.z = abs(d.z) > EPS ? d.z : (d.z >= 0 ? EPS : -EPS);

    vec3 t_coef = 1.0f / -abs(d);
    vec3 t_bias = t_coef * o;

    uint oct_mask = 0u;
    if (d.x > 0.0f)
        oct_mask ^= 1u, t_bias.x = 3.0f * t_coef.x - t_bias.x;
    if (d.y > 0.0f)
        oct_mask ^= 2u, t_bias.y = 3.0f * t_coef.y - t_bias.y;
    if (d.z > 0.0f)
        oct_mask ^= 4u, t_bias.z = 3.0f * t_coef.z - t_bias.z;

    float t_min = max(max(2.0f * t_coef.x - t_bias.x, 2.0f * t_coef.y - t_bias.y), 2.0f * t_coef.z - t_bias.z);
    float t_max = min(min(t_coef.x - t_bias.x, t_coef.y - t_bias.y), t_coef.z - t_bias.z);
    t_min = max(t_min, 0.0f);
    float h = t_max;

    uint parent = 0u;
    uint cur = 0u;
    vec3 pos = vec3(1.0f);
    uint idx = 0u;
    if (1.5f * t_coef.x - t_bias.x > t_min)
        idx ^= 1u, pos.x = 1.5f;
    if (1.5f * t_coef.y - t_bias.y > t_min)
        idx ^= 2u, pos.y = 1.5f;
    if (1.5f * t_coef.z - t_bias.z > t_min)
        idx ^= 4u, pos.z = 1.5f;

    uint scale = STACK_SIZE - 1;
    float scale_exp2 = 0.5f;

    while (scale < STACK_SIZE) {
        if (cur == 0u)
            cur = uOctree[parent + (idx ^ oct_mask)];

        vec3 t_corner = pos * t_coef - t_bias;
        float tc_max = min(min(t_corner.x, t_corner.y), t_corner.z);

        if ((cur & 0x80000000u) != 0 && t_min <= t_max) {
            float half_scale_exp2 = scale_exp2 * 0.5f;
            vec3 t_center = half_scale_exp2 * t_coef + t_corner;

            if ((cur & 0x40000000u) != 0) {
                o_pos = (1.0f + scale_exp2) * pos - 1.0f;
                uint data = cur & 0x3fffffffu;
                o_color = vec3(float(data & 0xffu), float((data >> 8u) & 0xffu), float((data >> 16u) & 0xffu)) / 255.0f;
                o_normal = vec3(0.0f, 1.0f, 0.0f);
                return true;
            }

            if (tc_max < h)
                stack[scale] = parent;
            h = tc_max;

            parent = cur & 0x3fffffffu;
            idx = 0u;
            --scale;
            scale_exp2 = half_scale_exp2;
            if (t_center.x > t_min)
                idx ^= 1u, pos.x += scale_exp2;
            if (t_center.y > t_min)
                idx ^= 2u, pos.y += scale_exp2;
            if (t_center.z > t_min)
                idx ^= 4u, pos.z += scale_exp2;

            cur = 0u;
            t_max = tc_max;
        } else {
            ++scale;
            pos.x -= scale_exp2;
            pos.y -= scale_exp2;
            pos.z -= scale_exp2;

            if ((idx & 1u) != 0u) pos.x += scale_exp2;
            if ((idx & 2u) != 0u) pos.y += scale_exp2;
            if ((idx & 4u) != 0u) pos.z += scale_exp2;

            scale_exp2 *= 2.0f;
            cur = 0u;

            if (scale >= STACK_SIZE)
                return false;

            parent = stack[scale];
            t_max = h;

            uint sh = scale - STACK_SIZE + 1;
            if ((idx & 1u) != 0u) pos.x -= exp2(sh);
            if ((idx & 2u) != 0u) pos.y -= exp2(sh);
            if ((idx & 4u) != 0u) pos.z -= exp2(sh);

            idx ^= 1u;
            if ((idx & 1u) != 0u) pos.x += exp2(sh);
            if (1.5f * t_coef.x - t_bias.x <= t_min) {
                idx ^= 2u;
                if ((idx & 2u) != 0u) pos.y += exp2(sh);
                if (1.5f * t_coef.y - t_bias.y <= t_min) {
                    idx ^= 4u;
                    if ((idx & 4u) != 0u) pos.z += exp2(sh);
                }
            }
        }
    }
    return false;
}

void main() {
    vec3 pos, color, normal;
    bool hit = RayMarchLeaf(uRayOrigin, uRayDirection, pos, color, normal);
    
    if (hit) {
        uint level_dim = kVoxelResolution;
        vec3 voxel_pos_f = (pos + 1.0) * 0.5 * float(level_dim);
        uvec3 voxel_pos = uvec3(clamp(voxel_pos_f, vec3(0.0), vec3(float(level_dim - 1u))));
        
        uint idx = 0u, cur = 0u;
        do {
            bvec3 cmp = greaterThanEqual(voxel_pos, uvec3(level_dim >>= 1));
            idx = cur | uint(cmp.x) | (uint(cmp.y) << 1u) | (uint(cmp.z) << 2u);
            cur = uOctree[idx] & 0x3fffffffu;
            voxel_pos -= uvec3(cmp) * level_dim;
        } while (cur != 0 && level_dim > 1u);
        
        if (level_dim == 1u && (uOctree[idx] & 0x80000000u) != 0u) {
            atomicAnd(uOctree[idx], 0x7fffffffu);
        }
    }
}
